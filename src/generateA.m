% This script contains the function for the creation of the matrix A, given
% the graph G, the fixation probability, the threshold for prunning the
% matrix and a flag (extinction) that states if the b vector to be
% generated refers to extinction probabilities or not
%
% Returns the matrix A, the results vector b and the inverse representations
% of the nodes subsets. The latter is a dictionary, which maps a binary
% string (e.g. 00101 states that nodes 3 and 5 are mutants) to the correct
% row index of the matrix A

function [A, b, inv_reprs] = generateA2(G, r, threshold, extinction)
    % Initialization
    if nargin < 3
        threshold = 0;
        extinction = 0;
    elseif nargin == 3
        extinction = 0;
    end

    num_nodes = length(G);
    num = 0;

    if threshold > 0 && threshold <= num_nodes
        if ~extinction
            low = 0;
            high = threshold;
        else
            low = num_nodes - threshold;
            high = num_nodes;
        end

        for k = low:high
            num = num + nchoosek(num_nodes, k);
        end
    else
        num = 2^num_nodes;
    end

    A = zeros(num);
    b = zeros(num, 1);

    if threshold > 0 && threshold < num_nodes
        reprs = get_representations(num_nodes, num, threshold, extinction);
    else
        reprs = get_representations(num_nodes, num, num_nodes, extinction);
    end

    inv_reprs = dictionary(reprs, transpose((1:num)));

    if ~extinction
        low = 2;
        if threshold > 0 && threshold < num_nodes
            high = num;
        else
            high = num-1;
        end
    else
        high = num-1;
        if threshold > 0 && threshold < num_nodes
            low = 1;
        else
            low = 2;
        end
    end

    %------Upper triangle initialization-------%
    for row = low:high
        %----Loop for all the combinations of residents-mutants----%
        % Combination is generated by the conversion of the row-1 (because
        % indexing in MATLAB starts from 1) by decimal to binary and
        % reversed
        row_bin = reprs(row,:);
        zeros_idxs = strfind(row_bin, '0'); % Get residents

        num_residents = length(zeros_idxs);
        num_mutants = length(row_bin) - num_residents;

        if extinction == 1 || threshold == 0 || num_mutants < threshold
            for j = zeros_idxs
                % Perform a bit change (i.e., transform a resident to mutant
                % each time), flip the binary string, convert to decimal+1 to
                % get the corresponding column (i.e., S -> S U {x} ). 
                % Then, store the appropriate number to each cell of A
                col_bin = row_bin;
                col_bin(j) = '1';
                col = inv_reprs(col_bin);

                A(row, col) = - num_mutants;
            end
        else
            b(row) = num_residents * num_mutants;
        end
    end

    % Correction of upper diagonal values
    A = (r/(num_nodes-1)) * A;
    b = (r/(num_nodes-1)) * b;

    %------Lower triangle initialization-------%

    % Get probabilities of each resident "hitting" an adjacent node.
    % By adding the columns for each row in the adjacency matrix we get 
    % the number of adjacent nodes of each node
    probs = 1./sum(G, 2);

    for row = low:high
        %----Loop for all the combinations of residents-mutants----%
        
        % Same as before for the upper triangular
        % bin = toBin(row-1, num); % Left2Right
        
        row_bin = reprs(row,:);
        zeros_idxs = strfind(row_bin, '0');

        for j = zeros_idxs
            % For each resident node, we can get the adjacent mutant nodes
            % doing the following procedure:
            %
            % 1)    Get the adjacent nodes from the adjacency matrix. This 
            %       is a binary string and convert to decimal.
            % 2)    Perform the AND operation between the residents-mutants 
            %       combination decimal representation and the adjacent 
            %       nodes decimal representation. We need decimals for 
            %       these operation according to MATLAB.
            %
            % This gives us the adjacent mutant nodes decimal 
            % representation of the current resident node. Then, we convert
            % this number to a binary then flip.

            sinks = sprintf("%d", G(j, :)); % Left2Right
            hits = dec2bin(bitand(bin2dec(sinks), bin2dec(row_bin)), num_nodes);
            hits_idxs = strfind(hits, '1');

            if extinction == 0 || threshold == 0 || length(zeros_idxs) + 1 <= threshold
                for i = hits_idxs
                    % Perform a bit change (i.e., transform an adjacent mutant
                    % node to resident each time), flip the binary string,
                    % transform to decimal and add 1 to get the corresponding
                    % column (i.e., S -> S - {x}). Then, subtract the
                    % corresponding probability from each cell accessed.
                    col_bin = row_bin;
                    col_bin(i) = '0'; % Left2Right
                    col = inv_reprs(col_bin);
    
                    A(row, col) = A(row, col) - probs(j);
                end
            else
                b(row) = b(row) + length(hits_idxs) * probs(j);
            end
        end

    end


    if threshold == 0 || threshold == length(G)
        if ~extinction
            b(num) = 1;
        else
            b(1) = 1;
        end
    end

    %------Diagonal of A initialization-------%
    for i = 1:length(A)
        A(i,i) = - sum(A(i,:)) + b(i);
    end
    
    if ~extinction
        A(1, 1) = 1;
    else
        A(num, num) = 1;
    end

    % if (threshold == 0 || threshold == size(G, 1))
    %     if ~extinction
    %         A(1, 1) = 1;
    %     else
    %         A(num, num) = 1;
    %     end
    % end
end

function repr = get_representations(num_nodes, num, threshold, extinction)
    repr = zeros(num, 1);
    start_idx = 1;

    if ~extinction
        low = 0;
        high = threshold;
    else
        low = num_nodes - threshold;
        high = num_nodes;
    end

    for k = low:high
        len_new_vals = nchoosek(num_nodes, k);   % How many entries with k ones
        end_idx = start_idx + len_new_vals - 1;  % Where to stop for these values

        repr(start_idx:end_idx) = sum(nchoosek(2.^(0:num_nodes-1), k), 2);   % Calculation of the decimal numbers
        
        start_idx = end_idx + 1;
    end

    repr = fliplr(dec2bin(repr, num_nodes));
end
